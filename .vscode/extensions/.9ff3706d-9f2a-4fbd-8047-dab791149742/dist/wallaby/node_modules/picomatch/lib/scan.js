'use strict';
var utils = require('./utils');
var _a = require('./constants'), CHAR_ASTERISK = _a.CHAR_ASTERISK, /* * */ CHAR_AT = _a.CHAR_AT, /* @ */ CHAR_BACKWARD_SLASH = _a.CHAR_BACKWARD_SLASH, /* \ */ CHAR_COMMA = _a.CHAR_COMMA, /* , */ CHAR_DOT = _a.CHAR_DOT, /* . */ CHAR_EXCLAMATION_MARK = _a.CHAR_EXCLAMATION_MARK, /* ! */ CHAR_FORWARD_SLASH = _a.CHAR_FORWARD_SLASH, /* / */ CHAR_LEFT_CURLY_BRACE = _a.CHAR_LEFT_CURLY_BRACE, /* { */ CHAR_LEFT_PARENTHESES = _a.CHAR_LEFT_PARENTHESES, /* ( */ CHAR_LEFT_SQUARE_BRACKET = _a.CHAR_LEFT_SQUARE_BRACKET, /* [ */ CHAR_PLUS = _a.CHAR_PLUS, /* + */ CHAR_QUESTION_MARK = _a.CHAR_QUESTION_MARK, /* ? */ CHAR_RIGHT_CURLY_BRACE = _a.CHAR_RIGHT_CURLY_BRACE, /* } */ CHAR_RIGHT_PARENTHESES = _a.CHAR_RIGHT_PARENTHESES, /* ) */ CHAR_RIGHT_SQUARE_BRACKET = _a.CHAR_RIGHT_SQUARE_BRACKET /* ] */;
var isPathSeparator = function (code) {
    return code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;
};
var depth = function (token) {
    if (token.isPrefix !== true) {
        token.depth = token.isGlobstar ? Infinity : 1;
    }
};
/**
 * Quickly scans a glob pattern and returns an object with a handful of
 * useful properties, like `isGlob`, `path` (the leading non-glob, if it exists),
 * `glob` (the actual pattern), `negated` (true if the path starts with `!` but not
 * with `!(`) and `negatedExtglob` (true if the path starts with `!(`).
 *
 * ```js
 * const pm = require('picomatch');
 * console.log(pm.scan('foo/bar/*.js'));
 * { isGlob: true, input: 'foo/bar/*.js', base: 'foo/bar', glob: '*.js' }
 * ```
 * @param {String} `str`
 * @param {Object} `options`
 * @return {Object} Returns an object with tokens and regex source string.
 * @api public
 */
var scan = function (input, options) {
    var opts = options || {};
    var length = input.length - 1;
    var scanToEnd = opts.parts === true || opts.scanToEnd === true;
    var slashes = [];
    var tokens = [];
    var parts = [];
    var str = input;
    var index = -1;
    var start = 0;
    var lastIndex = 0;
    var isBrace = false;
    var isBracket = false;
    var isGlob = false;
    var isExtglob = false;
    var isGlobstar = false;
    var braceEscaped = false;
    var backslashes = false;
    var negated = false;
    var negatedExtglob = false;
    var finished = false;
    var braces = 0;
    var prev;
    var code;
    var token = { value: '', depth: 0, isGlob: false };
    var eos = function () { return index >= length; };
    var peek = function () { return str.charCodeAt(index + 1); };
    var advance = function () {
        prev = code;
        return str.charCodeAt(++index);
    };
    while (index < length) {
        code = advance();
        var next = void 0;
        if (code === CHAR_BACKWARD_SLASH) {
            backslashes = token.backslashes = true;
            code = advance();
            if (code === CHAR_LEFT_CURLY_BRACE) {
                braceEscaped = true;
            }
            continue;
        }
        if (braceEscaped === true || code === CHAR_LEFT_CURLY_BRACE) {
            braces++;
            while (eos() !== true && (code = advance())) {
                if (code === CHAR_BACKWARD_SLASH) {
                    backslashes = token.backslashes = true;
                    advance();
                    continue;
                }
                if (code === CHAR_LEFT_CURLY_BRACE) {
                    braces++;
                    continue;
                }
                if (braceEscaped !== true && code === CHAR_DOT && (code = advance()) === CHAR_DOT) {
                    isBrace = token.isBrace = true;
                    isGlob = token.isGlob = true;
                    finished = true;
                    if (scanToEnd === true) {
                        continue;
                    }
                    break;
                }
                if (braceEscaped !== true && code === CHAR_COMMA) {
                    isBrace = token.isBrace = true;
                    isGlob = token.isGlob = true;
                    finished = true;
                    if (scanToEnd === true) {
                        continue;
                    }
                    break;
                }
                if (code === CHAR_RIGHT_CURLY_BRACE) {
                    braces--;
                    if (braces === 0) {
                        braceEscaped = false;
                        isBrace = token.isBrace = true;
                        finished = true;
                        break;
                    }
                }
            }
            if (scanToEnd === true) {
                continue;
            }
            break;
        }
        if (code === CHAR_FORWARD_SLASH) {
            slashes.push(index);
            tokens.push(token);
            token = { value: '', depth: 0, isGlob: false };
            if (finished === true)
                continue;
            if (prev === CHAR_DOT && index === (start + 1)) {
                start += 2;
                continue;
            }
            lastIndex = index + 1;
            continue;
        }
        if (opts.noext !== true) {
            var isExtglobChar = code === CHAR_PLUS
                || code === CHAR_AT
                || code === CHAR_ASTERISK
                || code === CHAR_QUESTION_MARK
                || code === CHAR_EXCLAMATION_MARK;
            if (isExtglobChar === true && peek() === CHAR_LEFT_PARENTHESES) {
                isGlob = token.isGlob = true;
                isExtglob = token.isExtglob = true;
                finished = true;
                if (code === CHAR_EXCLAMATION_MARK && index === start) {
                    negatedExtglob = true;
                }
                if (scanToEnd === true) {
                    while (eos() !== true && (code = advance())) {
                        if (code === CHAR_BACKWARD_SLASH) {
                            backslashes = token.backslashes = true;
                            code = advance();
                            continue;
                        }
                        if (code === CHAR_RIGHT_PARENTHESES) {
                            isGlob = token.isGlob = true;
                            finished = true;
                            break;
                        }
                    }
                    continue;
                }
                break;
            }
        }
        if (code === CHAR_ASTERISK) {
            if (prev === CHAR_ASTERISK)
                isGlobstar = token.isGlobstar = true;
            isGlob = token.isGlob = true;
            finished = true;
            if (scanToEnd === true) {
                continue;
            }
            break;
        }
        if (code === CHAR_QUESTION_MARK) {
            isGlob = token.isGlob = true;
            finished = true;
            if (scanToEnd === true) {
                continue;
            }
            break;
        }
        if (code === CHAR_LEFT_SQUARE_BRACKET) {
            while (eos() !== true && (next = advance())) {
                if (next === CHAR_BACKWARD_SLASH) {
                    backslashes = token.backslashes = true;
                    advance();
                    continue;
                }
                if (next === CHAR_RIGHT_SQUARE_BRACKET) {
                    isBracket = token.isBracket = true;
                    isGlob = token.isGlob = true;
                    finished = true;
                    break;
                }
            }
            if (scanToEnd === true) {
                continue;
            }
            break;
        }
        if (opts.nonegate !== true && code === CHAR_EXCLAMATION_MARK && index === start) {
            negated = token.negated = true;
            start++;
            continue;
        }
        if (opts.noparen !== true && code === CHAR_LEFT_PARENTHESES) {
            isGlob = token.isGlob = true;
            if (scanToEnd === true) {
                while (eos() !== true && (code = advance())) {
                    if (code === CHAR_LEFT_PARENTHESES) {
                        backslashes = token.backslashes = true;
                        code = advance();
                        continue;
                    }
                    if (code === CHAR_RIGHT_PARENTHESES) {
                        finished = true;
                        break;
                    }
                }
                continue;
            }
            break;
        }
        if (isGlob === true) {
            finished = true;
            if (scanToEnd === true) {
                continue;
            }
            break;
        }
    }
    if (opts.noext === true) {
        isExtglob = false;
        isGlob = false;
    }
    var base = str;
    var prefix = '';
    var glob = '';
    if (start > 0) {
        prefix = str.slice(0, start);
        str = str.slice(start);
        lastIndex -= start;
    }
    if (base && isGlob === true && lastIndex > 0) {
        base = str.slice(0, lastIndex);
        glob = str.slice(lastIndex);
    }
    else if (isGlob === true) {
        base = '';
        glob = str;
    }
    else {
        base = str;
    }
    if (base && base !== '' && base !== '/' && base !== str) {
        if (isPathSeparator(base.charCodeAt(base.length - 1))) {
            base = base.slice(0, -1);
        }
    }
    if (opts.unescape === true) {
        if (glob)
            glob = utils.removeBackslashes(glob);
        if (base && backslashes === true) {
            base = utils.removeBackslashes(base);
        }
    }
    var state = {
        prefix: prefix,
        input: input,
        start: start,
        base: base,
        glob: glob,
        isBrace: isBrace,
        isBracket: isBracket,
        isGlob: isGlob,
        isExtglob: isExtglob,
        isGlobstar: isGlobstar,
        negated: negated,
        negatedExtglob: negatedExtglob
    };
    if (opts.tokens === true) {
        state.maxDepth = 0;
        if (!isPathSeparator(code)) {
            tokens.push(token);
        }
        state.tokens = tokens;
    }
    if (opts.parts === true || opts.tokens === true) {
        var prevIndex = void 0;
        for (var idx = 0; idx < slashes.length; idx++) {
            var n = prevIndex ? prevIndex + 1 : start;
            var i = slashes[idx];
            var value = input.slice(n, i);
            if (opts.tokens) {
                if (idx === 0 && start !== 0) {
                    tokens[idx].isPrefix = true;
                    tokens[idx].value = prefix;
                }
                else {
                    tokens[idx].value = value;
                }
                depth(tokens[idx]);
                state.maxDepth += tokens[idx].depth;
            }
            if (idx !== 0 || value !== '') {
                parts.push(value);
            }
            prevIndex = i;
        }
        if (prevIndex && prevIndex + 1 < input.length) {
            var value = input.slice(prevIndex + 1);
            parts.push(value);
            if (opts.tokens) {
                tokens[tokens.length - 1].value = value;
                depth(tokens[tokens.length - 1]);
                state.maxDepth += tokens[tokens.length - 1].depth;
            }
        }
        state.slashes = slashes;
        state.parts = parts;
    }
    return state;
};
module.exports = scan;
